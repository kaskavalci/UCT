	void cross2(Individual&, Individual&, Individual&, Individual&);
	void cross3(Individual&, Individual&, Individual&, Individual&);
	void buildtimetableold();
	int getc2idx(int);
	void hc122();
	void hc2();
	void hc1g();
	void hc12g();
	void hc2g();
	void mutate2(int, int);
	void mutatehg1();
	void mutatehg3();
	void mutatehg5();
	void printjava();
	void printtt();
	void readind();
	void writeind();
	void writetime();
	void readtime();
	
	int findmin();
int Population::findmin() {
	int max, maxi, i;
	maxi = -1;
	max = -1;
	for (i = 0; i < POPUL; i++)
		if (max < pop[i].fitnessh + pop[i].fitnessh1 + pop[i].fitnessh2) {
			max = pop[i].fitnessh + pop[i].fitnessh1 + pop[i].fitnessh2;
			maxi = i;
		}
	return maxi % POPUL;
}
	int findmax();
int Population::findmax() {
	int max, maxi, i;
	maxi = -1;
	max = 300000;
	for (i = 0; i < POPUL; i++)
		if (max > pop[i].fitnessh + pop[i].fitnessh1 + pop[i].fitnessh2) {
			max = pop[i].fitnessh + pop[i].fitnessh1 + pop[i].fitnessh2;
			maxi = i;
		}
	return maxi % POPUL;
}


void selection(Individual&, Individual&);
void Population::selection(Individual&parent1, Individual&parent2) {
	int i, sel, selsize;
	int popsel[POPUL];
	int dom1i1 = 0;
	int dom1i2 = 0;
	int dom2i1 = 0;
	int dom2i2 = 0;
	int sel1, sel2, selx;
	Individual p1(conf), p2(conf), p3(conf), p4(conf);
	selsize = (int) (POPUL * 0.1);
	int popselidx[selsize];
	for (i = 0; i < POPUL; i++)
		popsel[i] = 0;
	for (i = 0; i < selsize; i++)
		popselidx[i] = -1;
	for (i = 0; i < selsize; i++) {
		sel = RND(POPUL);
		while (popsel[sel] == 1) {
			sel = RND(POPUL);
		}
		popsel[sel] = 1;
		popselidx[i] = sel;
	}
	sel1 = RND(POPUL);
	sel2 = RND(POPUL);
	while (sel1 == sel2) {
		sel2 = RND(POPUL);
	}
	p1.copyindividual(pop[sel1], p1);
	p2.copyindividual(pop[sel2], p2);
	for (i = 0; i < selsize; i++) {
		if (p1.dominates(p1, pop[popselidx[i]]) == 1)
			dom1i1++;
		if (p1.dominates(p1, pop[popselidx[i]]) == 2)
			dom2i1++;
		if (p2.dominates(p2, pop[popselidx[i]]) == 1)
			dom1i2++;
		if (p2.dominates(p2, pop[popselidx[i]]) == 2)
			dom2i2++;
	}
	if (dom1i1 == selsize && dom2i2 == selsize)
		parent1.copyindividual(p1, parent1);
	else if (dom1i2 == selsize && dom2i1 == selsize)
		parent1.copyindividual(p2, parent1);
	else {
		selx = RND(2);
		if (selx == 0)
			parent1.copyindividual(p1, parent1);
		else
			parent1.copyindividual(p2, parent1);
	}
	dom1i1 = 0;
	dom1i2 = 0;
	dom2i1 = 0;
	dom2i2 = 0;
	sel1 = RND(POPUL);
	sel2 = RND(POPUL);
	while (sel1 == sel2) {
		sel2 = RND(POPUL);
	}
	p3.copyindividual(pop[sel1], p3);
	p4.copyindividual(pop[sel2], p4);
	for (i = 0; i < selsize; i++) {
		if (p3.dominates(p3, pop[popselidx[i]]) == 1)
			dom1i1++;
		if (p3.dominates(p3, pop[popselidx[i]]) == 2)
			dom2i1++;
		if (p4.dominates(p4, pop[popselidx[i]]) == 1)
			dom1i2++;
		if (p4.dominates(p4, pop[popselidx[i]]) == 2)
			dom2i2++;
	}
	if (dom1i1 == selsize && dom2i2 == selsize)
		parent2.copyindividual(p3, parent2);
	else if (dom1i2 == selsize && dom2i1 == selsize)
		parent2.copyindividual(p4, parent2);
	else {
		selx = RND(2);
		if (selx == 0)
			parent2.copyindividual(p3, parent2);
		else
			parent2.copyindividual(p4, parent2);
	}
}

void nextgenold(Individual&);
void Population::nextgenold(Individual&child) {
	Individual tmpind(conf);
	int i, domination = -1;
	size_t j;
	for (j = 0; j < paretof.size(); j++) {
		if (child.dominates(child, pop[paretof[j]]) == 1) {
			child.copyindividual(pop[paretof[j]], tmpind);
			child.copyindividual(child, pop[paretof[j]]);
			domination = 1;
			break;
		}
		if (child.dominates(child, pop[paretof[j]]) == 2) {
			domination = 2;
			break;
		}
	}
	for (i = 0; i < POPUL; i++) {
		if (domination == 1 && tmpind.dominates(tmpind, pop[i]) == 1) {
			tmpind.copyindividual(tmpind, pop[i]);
			break;
		}
		if (domination == -1 && child.dominates(child, pop[i]) == 1) {
			child.copyindividual(child, pop[i]);
			break;
		}
		if (domination == 2 && child.dominates(child, pop[i]) == 1) {
			child.copyindividual(child, pop[i]);
			break;
		}
	}
	if (domination == 4) {
	}
}

void Individual::readtime() {
	int j, k;
	FILE*indf = fopen("time.txt", "r");
	for (j = 0; j < 5; j++) {
		for (k = 0; k < 4; k++) {
			fscanf(indf, "%d\n", &timetable1[j][k]);
			fscanf(indf, "%d\n", &timetable2[j][k]);
		}
	}
	fclose(indf);
}

void Individual::writetime() {
	int j, k;
	FILE*indf = fopen("time.txt", "w");
	for (j = 0; j < 5; j++) {
		for (k = 0; k < 4; k++) {
			fprintf(indf, "%d\n", timetable1[j][k]);
			fprintf(indf, "%d\n", timetable2[j][k]);
		}
	}
	fclose(indf);
}
void Individual::writeind() {
	int i, j, k;
	FILE*indf = fopen("individual.txt", "w");
	FILE*javaf = fopen("solution.txt", "w");
	for (i = 0; i < CHROML; i++) {
		fprintf(indf, "%d\n", chrom[i]);
	}
	for (j = 0; j < 5; j++) {
		for (k = 0; k < 4; k++) {
			fprintf(indf, "%d\n", timetable1[j][k]);
			fprintf(indf, "%d\n", timetable2[j][k]);
		}
	}
	fprintf(indf, "%d\n", fitnessh);
	fprintf(indf, "%d\n", fitnessf);
	fprintf(indf, "%d\n", fitnessf1);
	fprintf(indf, "%d\n", fitnessf2);
	fprintf(indf, "%d\n", fitnessf3);
	fprintf(indf, "%d\n", c2cnt);
	for (i = 0; i < CHROML; i++) {
		fprintf(indf, "%d	%d\n", day[i], slot[i]);
	}
	for (i = 0; i < CHROML; i++) {
		fprintf(javaf, "%d	%d\n", day[i], slot[i]);
	}
	fclose(indf);
	fclose(javaf);
}

void Individual::readind() {
	int i, j, k;
	FILE*indf = fopen("individual.txt", "r");
	FILE*javaf = fopen("solution.txt", "r");
	for (i = 0; i < CHROML; i++) {
		fscanf(indf, "%d\n", &chrom[i]);
	}
	for (j = 0; j < 5; j++) {
		for (k = 0; k < 4; k++) {
			fscanf(indf, "%d\n", &timetable1[j][k]);
			fscanf(indf, "%d\n", &timetable2[j][k]);
		}
	}
	fscanf(indf, "%d\n", &fitnessh);
	fscanf(indf, "%d\n", &fitnessf);
	fscanf(indf, "%d\n", &fitnessf1);
	fscanf(indf, "%d\n", &fitnessf2);
	fscanf(indf, "%d\n", &fitnessf3);
	fscanf(indf, "%d\n", &c2cnt);
	for (i = 0; i < CHROML; i++) {
		fscanf(indf, "%d	%d\n", &day[i], &slot[i]);
	}
	fclose(indf);
	fclose(javaf);
}

void Individual::printtt() {
	int i, j;
	for (i = 0; i < 5; i++) {
		for (j = 0; j < 4; j++) {
			printf("tt1 day slot tt %d %d %d\n", i, j, timetable1[i][j]);
		}
	}
	for (i = 0; i < 5; i++) {
		for (j = 0; j < 4; j++) {
			printf("tt2 day slot tt %d %d %d\n", i, j, timetable2[i][j]);
		}
	}
}

void Individual::printjava() {
	int i;
	FILE*javaf = fopen("solution.txt", "w");
	for (i = 0; i < CHROML; i++) {
		printf("%d	%d\n", day[i], slot[i]);
		fprintf(javaf, "%d	%d\n", day[i], slot[i]);
	}
	fclose(javaf);
}

void Individual::mutatehg5() {
	int i, sel;
	int pos1, pos2, pos3;
	int val1, val2, val3;
	pos1 = RND(chrom_length);
	pos2 = RND(chrom_length);
	while (pos1 == pos2) {
		pos2 = RND(POPUL);
	}
	pos3 = RND(chrom_length);
	while (pos3 == pos2 || pos3 == pos1) {
		pos3 = RND(POPUL);
	}
	val1 = chrom[pos1];
	val2 = chrom[pos2];
	val3 = chrom[pos3];
	for (i = 0; i < chrom_length; i++) {
		sel = RND(2);
		if (chrom[i] == val3 && sel == 0 && RND(100) < 50) {
			chrom[i] = val1;
			day[i] = chrom[i] / no_periods;
			slot[i] = chrom[i] % no_periods;
		} else if (chrom[i] == val3 && sel == 1 && RND(100) < 50) {
			chrom[i] = val2;
			day[i] = chrom[i] / no_periods;
			slot[i] = chrom[i] % no_periods;
		}
	}
}
void Individual::mutatehg3() {
	int i;
	int pos1, pos2;
	int val1, val2;
	pos1 = RND(chrom_length);
	pos2 = RND(chrom_length);
	while (pos1 == pos2) {
		pos2 = RND(POPUL);
	}
	val1 = chrom[pos1];
	val2 = chrom[pos2];
	for (i = 0; i < chrom_length; i++) {
		if (chrom[i] == val1 && RND(100) < 50) {
			chrom[i] = val2;
			day[i] = chrom[i] / no_periods;
			slot[i] = chrom[i] % no_periods;
		}
	}
}

void Individual::mutate2(int pos, int val) {
	if (conf->courmat[pos].c2 != 1) {
		chrom[pos] = val;
		day[pos] = chrom[pos] / 4;
		slot[pos] = chrom[pos] % 4;
	}
}

void Individual::mutatehg1() {
	int col1, col2, i;
	col1 = RND(no_colors);
	col2 = RND(no_colors);
	if (col1 == col2)
		return;
	for (i = 0; i < chrom_length; i++) {
		if (chrom[i] == col1) {
			chrom[i] = col2;
			day[i] = chrom[i] / no_periods;
			slot[i] = chrom[i] % no_periods;
		} else if (chrom[i] == col2) {
			chrom[i] = col1;
			day[i] = chrom[i] / no_periods;
			slot[i] = chrom[i] % no_periods;
		}
	}
}
	
void Individual::hc12g() {
	int n;

	Individual*hcchild, *hcchild2;
	hcchild = new Individual(conf);
	hcchild2 = new Individual(conf);
	hcchild2->copyindividual(*this, *hcchild2);
	hcchild2->buildtimetable();


	hcchild->copyindividual(*this, *hcchild);
	for (n = 0; n < conf->hciter; n++) {
		hcchild->copyindividual(*this, *hcchild);
		if (RND(100) < 33)
			hcchild->mutatehg1();
		else if (RND(100) < 66)
			hcchild->mutatehg3();
		else
			hcchild->mutatehg5();
		hcchild->buildtimetable();

		if ((hcchild->fitnessh + hcchild->fitnessh1 + hcchild->fitnessh2
				< this->fitnessh + this->fitnessh1 + this->fitnessh2)) {
			hcchild->copyindividual(*hcchild, *this);
		}
	}
	conflv.clear();
	conflvh.clear();
	conflvf.clear();
	while (conflv.size() != 0) {
		conflv.pop_back();
	}
	delete hcchild;
	delete hcchild2;
}
	
void Individual::hc1g() {
	int rndidx;
	int n;
	int selcolor;
	Individual*hcchild, *hcchild2;
	hcchild = new Individual(conf);
	hcchild2 = new Individual(conf);
	hcchild2->copyindividual(*this, *hcchild2);
	hcchild2->buildtimetable();

	if (RND(1000) < 1000 * conf->hillrnd || conflv.size() == 0)
		rndidx = RND(chrom_length);
	else
		rndidx = conflv[RND(conflv.size())];
	hcchild->copyindividual(*this, *hcchild);
	for (n = 0; n < conf->hciter; n++) {
		selcolor = n;
		if (hcchild->chrom[rndidx] == selcolor)
			continue;
		if (RND(100) < 33)
			hcchild->mutatehg1();
		else if (RND(100) < 66)
			hcchild->mutatehg3();
		else
			hcchild->mutatehg5();
		hcchild->buildtimetable();

		if ((hcchild->fitnessh + hcchild->fitnessh1 + hcchild->fitnessh2
				< this->fitnessh + this->fitnessh1 + this->fitnessh2)\

				&& (hcchild->fitnessf + hcchild->fitnessf1 + hcchild->fitnessf2 + hcchild->fitnessf3
						< this->fitnessf + this->fitnessf1 + this->fitnessf2 + this->fitnessf3)) {
			hcchild->copyindividual(*hcchild, *this);
		}
	}
	conflv.clear();
	conflvh.clear();
	conflvf.clear();
	while (conflv.size() != 0) {
		conflv.pop_back();
	}
	delete hcchild;
	delete hcchild2;
}
	
void Individual::hc2() {
	int rndidx;
	int n;
	int selcolor;
	Individual*hcchild, *hcchild2;
	hcchild = new Individual(conf);
	hcchild2 = new Individual(conf);
	if (this->fitnessf + this->fitnessf1 + this->fitnessf2 == 0) {
		hc1();
		return;
	}
	hcchild2->copyindividual(*this, *hcchild2);
	hcchild2->buildtimetable();


	if (RND(1000) < 1000 * conf->hillrnd || conflvf.size() == 0)
		rndidx = RND(chrom_length);
	else
		rndidx = conflvf[RND(conflvf.size())];
	hcchild->copyindividual(*this, *hcchild);
	for (n = 0; n < no_colors; n++) {
		selcolor = n;
		hcchild->mutatehc1(rndidx, selcolor);
		hcchild->buildtimetable();

		if ((hcchild->fitnessf + hcchild->fitnessf1 + hcchild->fitnessf2 + hcchild->fitnessf3
				< this->fitnessf + this->fitnessf1 + this->fitnessf2 + this->fitnessf3)) {
			hcchild->copyindividual(*hcchild, *this);
		}
	}
	conflv.clear();
	conflvh.clear();
	conflvf.clear();
	delete hcchild;
	delete hcchild2;
}
void Individual::hc2g() {
	int rndidx;
	int n, selcolor;
	Individual*hcchild, *hcchild2;
	hcchild = new Individual(conf);
	hcchild2 = new Individual(conf);
	hcchild2->copyindividual(*this, *hcchild2);
	hcchild2->buildtimetable();

	if (RND(1000) < 1000 * conf->hillrnd || conflv.size() == 0)
		rndidx = RND(chrom_length);
	else
		rndidx = conflv[RND(conflv.size())];
	hcchild->copyindividual(*this, *hcchild);
	for (n = 0; n < conf->hciter; n++) {
		selcolor = RND(no_colors);
		if (hcchild->chrom[rndidx] == selcolor)
			continue;
		if (RND(100) < 33)
			hcchild->mutatehg1();
		else if (RND(100) < 66)
			hcchild->mutatehg3();
		else
			hcchild->mutatehg5();
		hcchild->buildtimetable();

		if ((hcchild->fitnessf + hcchild->fitnessf1 + hcchild->fitnessf2 + hcchild->fitnessf3
				< this->fitnessf + this->fitnessf1 + this->fitnessf2 + this->fitnessf3)) {
			hcchild->copyindividual(*hcchild, *this);
		}
	}
	conflv.clear();
	conflvh.clear();
	conflvf.clear();
	while (conflv.size() != 0) {
		conflv.pop_back();
	}
	delete hcchild;
	delete hcchild2;
}

void Individual::hc122() {
	int rndidx;
	int n;
	int selcol;
	Individual*hcchild, *hcchild2;
	hcchild = new Individual(conf);
	hcchild2 = new Individual(conf);
	if (this->fitnessh + this->fitnessh1 + this->fitnessh2 == 0) {
		hc1();
		return;
	}
	hcchild2->copyindividual(*this, *hcchild2);
	hcchild2->buildtimetable();

	if (RND(1000) < 1000 * conf->hillrnd || conflvh.size() == 0)
		rndidx = RND(chrom_length);
	else if (conflvh.size() != 0)
		rndidx = conflvh[RND(conflvh.size())];
	else
		rndidx = RND(chrom_length);
	hcchild->copyindividual(*this, *hcchild);
	for (n = 0; n < no_colors; n++) {
		selcol = n;
		if (hcchild->chrom[rndidx] == selcol)
			continue;
		hcchild->mutatehc1(rndidx, selcol);
		hcchild->buildtimetable();

		if ((hcchild->fitnessh + hcchild->fitnessh1 + hcchild->fitnessh2
				< this->fitnessh + this->fitnessh1 + this->fitnessh2)) {
			hcchild->copyindividual(*hcchild, *this);
		}
	}
	conflv.clear();
	conflvh.clear();
	conflvf.clear();
	while (conflv.size() != 0) {
		conflv.pop_back();
	}
	delete hcchild;
	delete hcchild2;
}

int Individual::getc2idx(int gid) {
	int i, idx, found = 0;
	idx = -1;
	for (i = 0; i < CHROML; i++) {
		if (chrom[i] == gid && conf->courmat[i].c2 == 1) {
			found = 1;
			break;
		}
	}
	if (found == 1)
		idx = i;
	return idx;
}

void Individual::buildtimetableold() {
	int i, j;
	int tmpgids1[NCOL];
	int tmpgids2[NCOL];
	int dy = 0, slt = 0;
	for (i = 0; i < NCOL; i++) {
		tmpgids1[i] = 0;
		tmpgids2[i] = 0;
	}
	for (i = 0; i < 5; i++) {
		for (j = 0; j < 4; j++) {
			timetable1[i][j] = -1;
			timetable2[i][j] = -1;
		}
	}
	for (i = 0; i < CHROML; i++) {
		for (j = i + 1; j < CHROML; j++) {
			if ((conf->courmat[i].c2 == 1 && conf->courmat[i].hours == conf->courmat[j].hours) && (conf->courmat[j].c2 == 1)
					&& (conf->courmat[i].c2day == conf->courmat[j].c2day && conf->courmat[i].c2slot == conf->courmat[j].c2slot)) {
				chrom[j] = chrom[i];
			}
		}
	}
	for (i = 0; i < CHROML; i++) {
		if (conf->courmat[i].c2 == 1 && conf->courmat[i].hours == 1 && tmpgids1[chrom[i]] != 1) {
			timetable1[conf->courmat[i].c2day][conf->courmat[i].c2slot] = chrom[i];
			tmpgids1[chrom[i]] = 1;
		}
		if (conf->courmat[i].c2 == 1 && conf->courmat[i].hours == 2 && tmpgids2[chrom[i]] != 1) {
			timetable2[conf->courmat[i].c2day][conf->courmat[i].c2slot] = chrom[i];
			tmpgids2[chrom[i]] = 1;
		}
	}
	for (i = 0; i < NCOL; i++) {
		if (tmpgids1[i] == 1)
			continue;
		dy = 0;
		slt = 0;
		while (timetable1[dy][slt] != -1) {
			slt = (slt + 1) % 4;
			if (slt == 0)
				dy = (dy + 1) % 5;
		}
		timetable1[dy][slt] = i;
	}
	for (i = 0; i < NCOL; i++) {
		if (tmpgids2[i] == 1)
			continue;
		dy = 0;
		slt = 0;
		while (timetable2[dy][slt] != -1) {
			slt = (slt + 1) % 4;
			if (slt == 0)
				dy = (dy + 1) % 5;
		}
		timetable2[dy][slt] = i;
	}
	for (i = 0; i < CHROML; i++) {
		if (conf->courmat[i].hours == 1) {
			dy = 0;
			slt = 0;
			while (timetable1[dy][slt] != chrom[i]) {
				slt = (slt + 1) % 4;
				if (slt == 0)
					dy = (dy + 1) % 5;
			}
			day[i] = dy;
			slot[i] = slt;
		}
		if (conf->courmat[i].hours == 2) {
			dy = 0;
			slt = 0;
			while (timetable2[dy][slt] != chrom[i]) {
				slt = (slt + 1) % 4;
				if (slt == 0)
					dy = (dy + 1) % 5;
			}
			day[i] = dy;
			slot[i] = slt;
		}
	}
	fitnessHCAL(0);
	fitnessFCAL(0);
	fitnessF1CAL(0);
	fitnessF2CAL(0);
	fitnessF3CAL(0);
}

void Individual::cross2(Individual&p1, Individual&p2, Individual&ch1, Individual&ch2) {
	int pos1, pos2, i;
	pos1 = RND(chrom_length / 2);
	pos2 = chrom_length / 2 + RND(chrom_length / 2);
	for (i = 0; i < pos1; i++) {
		ch1.chrom[i] = p1.chrom[i];
	}
	for (i = pos1; i < pos2; i++) {
		ch1.chrom[i] = p2.chrom[i];
	}
	for (i = pos2; i < chrom_length; i++) {
		ch1.chrom[i] = p1.chrom[i];
	}
	for (i = 0; i < pos1; i++) {
		ch2.chrom[i] = p2.chrom[i];
	}
	for (i = pos1; i < pos2; i++) {
		ch2.chrom[i] = p1.chrom[i];
	}
	for (i = pos2; i < chrom_length; i++) {
		ch2.chrom[i] = p2.chrom[i];
	}
}
void Individual::cross3(Individual&p1, Individual&p2, Individual&ch1, Individual&ch2) {
	int i;
	for (i = 0; i < chrom_length; i++) {
		if (RND(100) < 50) {
			ch1.chrom[i] = p1.chrom[i];
			ch2.chrom[i] = p2.chrom[i];
		} else {
			ch1.chrom[i] = p2.chrom[i];
			ch2.chrom[i] = p1.chrom[i];
		}
	}
}